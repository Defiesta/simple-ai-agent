// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pragma solidity ^0.8.20;

import {IRiscZeroVerifier} from "risc0/IRiscZeroVerifier.sol";
import {ImageID} from "./ImageID.sol"; // auto-generated contract after running `cargo build`.
import {ITradingSignal} from "./ITradingSignal.sol";
import {Ownable} from "openzeppelin-contracts/contracts/access/Ownable.sol";

/// @title A DeFi trading signal generator using RISC Zero.
/// @notice This contract stores AI-generated trading signals verified through zero-knowledge proofs.
/// @dev This contract demonstrates verifiable ML computation using linear regression
///      to generate ETH trading signals with confidence scores.
contract TradingSignal is ITradingSignal, Ownable {
    /// @notice RISC Zero verifier contract address.
    IRiscZeroVerifier public immutable VERIFIER;
    
    /// @notice Image ID of the trading signal zkVM binary.
    ///         This ensures only proofs from the correct guest program are accepted.
    bytes32 public IMAGE_ID;

    /// @notice The latest trading signal generated by the AI.
    Signal public latestSignal;

    /// @notice Initialize the contract, binding it to a specified RISC Zero verifier.
    constructor(IRiscZeroVerifier _verifier) Ownable(msg.sender) {
        VERIFIER = _verifier;
        IMAGE_ID = ImageID.TRADING_SIGNAL_ID;
        // Initialize with neutral signal
        latestSignal = Signal({
            action: 0,
            confidence: 0,
            predictedPrice: 0,
            timestamp: block.timestamp
        });
    }

    /// @notice Set the image ID of the trading signal zkVM binary. Only the owner can call this.
    /// @param _imageId The new image ID to use for proof verification
    function setImageId(bytes32 _imageId) external onlyOwner {
        require(_imageId != bytes32(0), "Invalid image ID: cannot be zero");
        IMAGE_ID = _imageId;
        emit ImageIdUpdated(_imageId);
    }

    /// @notice Set a new trading signal. Requires a RISC Zero proof that the signal was generated correctly.
    /// @param action The trading action: 0 for SELL, 1 for BUY
    /// @param confidence The confidence score of the prediction (0-100)
    /// @param predictedPrice The predicted ETH price in wei (18 decimals)
    /// @param seal The RISC Zero proof seal
    function setSignal(
        uint8 action,
        uint256 confidence, 
        uint256 predictedPrice,
        bytes calldata seal
    ) public {
        require(action <= 1, "Invalid action: must be 0 (SELL) or 1 (BUY)");
        require(confidence <= 100, "Invalid confidence: must be 0-100");
        require(predictedPrice > 0, "Invalid predicted price: must be > 0");

        // Construct the expected journal data. Verify will fail if journal doesn't match.
        bytes memory journal = abi.encode(action, confidence, predictedPrice);
        VERIFIER.verify(seal, IMAGE_ID, sha256(journal));
        
        // Update the signal
        latestSignal = Signal({
            action: action,
            confidence: confidence,
            predictedPrice: predictedPrice,
            timestamp: block.timestamp
        });

        emit SignalUpdated(action, confidence, predictedPrice, block.timestamp);
    }

    /// @notice Returns the complete latest trading signal.
    function getLatestSignal() public view returns (Signal memory) {
        return latestSignal;
    }

    /// @notice Returns just the trading action from the latest signal.
    function getSignalAction() public view returns (uint8) {
        return latestSignal.action;
    }

    /// @notice Returns the confidence score of the latest signal.
    function getConfidence() public view returns (uint256) {
        return latestSignal.confidence;
    }

    /// @notice Returns the predicted price from the latest signal.
    function getPredictedPrice() public view returns (uint256) {
        return latestSignal.predictedPrice;
    }

    /// @notice Helper function to get human-readable action string.
    /// @return actionString "BUY" or "SELL"
    function getActionString() public view returns (string memory actionString) {
        return latestSignal.action == 1 ? "BUY" : "SELL";
    }

    /// @notice Check if the latest signal recommends buying.
    function shouldBuy() public view returns (bool) {
        return latestSignal.action == 1;
    }

    /// @notice Check if the latest signal recommends selling.
    function shouldSell() public view returns (bool) {
        return latestSignal.action == 0;
    }
}